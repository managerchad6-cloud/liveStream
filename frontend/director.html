<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Director Console</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0f1014;
      --panel: #1b1f2a;
      --text: #f0f2f8;
      --muted: #9aa4bf;
      --accent: #ffb347;
      --on-air: #f5d565;
      --danger: #ff6b6b;
      --good: #6ee7b7;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Space Grotesk', sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 20px;
      padding-bottom: 60px;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    h1 { margin: 0; font-size: 1.5rem; }

    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    button {
      padding: 8px 16px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-family: inherit;
      font-weight: 500;
    }

    .btn-primary { background: var(--accent); color: #000; }
    .btn-danger { background: var(--danger); color: #fff; }
    .btn-small { padding: 4px 10px; font-size: 0.85rem; }

    label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .panel {
      background: var(--panel);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .panel h2 {
      margin: 0 0 12px 0;
      font-size: 0.9rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Rendering section */
    #rendering-section {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      min-height: 50px;
      align-items: flex-start;
    }

    .rendering-card {
      background: #232838;
      padding: 10px 14px;
      border-radius: 8px;
      font-size: 0.85rem;
      min-width: 150px;
    }

    .rendering-card .type { font-weight: 600; }
    .rendering-card .seed { color: var(--muted); font-size: 0.8rem; margin: 4px 0; }
    .rendering-card.failed { border: 1px solid #c44; opacity: 0.7; }

    .progress-bar {
      height: 4px;
      background: #333;
      border-radius: 2px;
      overflow: hidden;
      margin-top: 6px;
    }

    .progress-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.3s;
    }

    /* Pipeline section - horizontal row, rightmost = on-air */
    #pipeline-section {
      display: flex;
      flex-direction: row;
      gap: 12px;
      overflow-x: auto;
      padding: 8px 0;
      min-height: 100px;
      align-items: stretch;
    }

    .pipeline-card {
      background: #232838;
      padding: 12px 16px;
      border-radius: 10px;
      min-width: 160px;
      max-width: 200px;
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
      transition: all 0.3s;
      border: 2px solid transparent;
    }

    .pipeline-card.on-air {
      background: linear-gradient(135deg, rgba(245,213,101,0.3), rgba(35,40,56,0.95));
      border: 2px solid var(--on-air);
      box-shadow: 0 0 25px rgba(245,213,101,0.4);
      animation: pulse 1.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 25px rgba(245,213,101,0.4); }
      50% { box-shadow: 0 0 35px rgba(245,213,101,0.6); }
    }

    .pipeline-card .type { font-weight: 600; font-size: 0.9rem; }
    .pipeline-card .seed { color: var(--muted); font-size: 0.8rem; }
    .pipeline-card .duration { color: var(--muted); font-size: 0.75rem; }

    .on-air-badge {
      background: var(--on-air);
      color: #000;
      font-weight: 700;
      padding: 3px 10px;
      border-radius: 4px;
      font-size: 0.7rem;
      align-self: flex-start;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Chat inbox */
    #chat-inbox {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      min-height: 50px;
    }

    .chat-card {
      background: #232838;
      padding: 12px;
      border-radius: 8px;
      max-width: 280px;
    }

    .chat-card .username { font-weight: 600; margin-bottom: 4px; font-size: 0.9rem; }
    .chat-card .text { font-size: 0.85rem; margin-bottom: 6px; }
    .chat-card .response-preview {
      font-size: 0.8rem;
      color: var(--muted);
      border-left: 2px solid var(--accent);
      padding-left: 8px;
      margin-bottom: 8px;
    }
    .chat-card .actions { display: flex; gap: 8px; }

    /* Archive */
    #archive-section {
      max-height: 150px;
      overflow-y: auto;
    }

    .archive-item {
      padding: 6px 0;
      border-bottom: 1px solid #2a3040;
      font-size: 0.8rem;
      color: var(--muted);
    }

    /* Director input */
    #director-input {
      display: flex;
      gap: 10px;
    }

    #director-input textarea {
      flex: 1;
      background: #232838;
      border: 1px solid #3a4050;
      border-radius: 8px;
      color: var(--text);
      padding: 10px;
      font-family: inherit;
      resize: none;
      height: 50px;
    }

    .empty-state {
      color: var(--muted);
      font-style: italic;
      padding: 16px;
    }

    #status-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--panel);
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: var(--muted);
      border-top: 1px solid #2a3040;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--good);
    }

    .status-dot.playing { background: var(--on-air); animation: blink 1s infinite; }
    .status-dot.paused { background: var(--accent); }
    .status-dot.stopped { background: var(--muted); }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Director Console</h1>
    <div class="controls">
      <label>
        <input type="checkbox" id="filler-toggle">
        Filler
      </label>
      <button class="btn-primary" id="play-btn">Play</button>
      <button class="btn-danger" id="pause-btn">Pause</button>
    </div>
  </header>

  <div class="panel">
    <h2>Rendering</h2>
    <div id="rendering-section">
      <span class="empty-state">No segments rendering</span>
    </div>
  </div>

  <div class="panel">
    <h2>Pipeline <span style="font-weight:normal;font-size:0.8rem;">(rightmost = on air)</span></h2>
    <div id="pipeline-section">
      <span class="empty-state">Pipeline empty</span>
    </div>
  </div>

  <div class="panel">
    <h2 style="display:flex;justify-content:space-between;align-items:center;">
      Chat Inbox
      <label style="font-size:0.8rem;text-transform:none;letter-spacing:0;">
        <input type="checkbox" id="auto-approve-toggle">
        Auto-approve
      </label>
    </h2>
    <div id="chat-inbox">
      <span class="empty-state">No messages</span>
    </div>
  </div>

  <div class="panel">
    <h2>Create Segment</h2>
    <div id="director-input">
      <textarea id="seed-input" placeholder="Enter a topic or question..."></textarea>
      <button class="btn-primary" id="create-btn">Create</button>
    </div>
  </div>

  <details class="panel">
    <summary style="cursor:pointer;color:var(--muted);">Archive</summary>
    <div id="archive-section"></div>
    <button class="btn-small btn-danger" id="clear-archive" style="margin-top:10px;">Clear</button>
  </details>

  <div id="status-bar">
    <div class="status-indicator">
      <div class="status-dot" id="status-dot"></div>
      <span id="playback-status">Connecting...</span>
    </div>
    <span id="buffer-info">Buffer: 0s</span>
  </div>

  <script>
    const API_BASE = window.location.origin;
    let ws = null;
    let currentSegmentId = null;

    async function apiGet(path) {
      const res = await fetch(API_BASE + path);
      return res.json();
    }

    async function apiPost(path, data) {
      const res = await fetch(API_BASE + path, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      return res.json();
    }

    function renderRendering(segments) {
      const forming = segments.filter(s => s.status === 'forming');
      const container = document.getElementById('rendering-section');

      if (forming.length === 0) {
        container.innerHTML = '<span class="empty-state">No segments rendering</span>';
        return;
      }

      container.innerHTML = forming.map(seg => {
        const failed = seg.renderProgress === -1;
        const pct = failed ? 0 : Math.round((seg.renderProgress || 0) * 100);
        const errorMsg = seg.metadata?.renderError || 'Failed';
        return `
          <div class="rendering-card${failed ? ' failed' : ''}" data-id="${seg.id}">
            <div style="display:flex;justify-content:space-between;align-items:center;">
              <div class="type">${seg.type}</div>
              <button class="btn-small btn-danger delete-rendering" style="padding:2px 6px;font-size:0.7rem;">X</button>
            </div>
            <div class="seed">${(seg.seed || 'filler').slice(0, 25)}${(seg.seed || '').length > 25 ? '...' : ''}</div>
            ${failed
              ? `<div style="font-size:0.75rem;color:#c44;margin-top:4px;">${errorMsg}</div>`
              : `<div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>
                 <div style="font-size:0.75rem;color:var(--muted);margin-top:4px;">${pct}%</div>`
            }
          </div>
        `;
      }).join('');

      // Attach delete handlers
      container.querySelectorAll('.delete-rendering').forEach(btn => {
        btn.addEventListener('click', async () => {
          const card = btn.closest('.rendering-card');
          const id = card.dataset.id;
          await fetch(`${API_BASE}/api/pipeline/${id}`, { method: 'DELETE' });
          refreshAll();
        });
      });
    }

    function renderPipeline(segments, onAirId) {
      // Get only ready segments, oldest first (index 0 = oldest = rightmost in UI)
      const ready = segments.filter(s => s.status === 'ready');
      const container = document.getElementById('pipeline-section');

      if (ready.length === 0) {
        container.innerHTML = '<span class="empty-state">Pipeline empty</span>';
        return;
      }

      // Reverse for display: newest on left, oldest (on-air) on right
      const displayOrder = [...ready].reverse();

      container.innerHTML = displayOrder.map((seg, index) => {
        // The last one in display (rightmost) is the on-air one (index 0 in original array)
        const isOnAir = index === displayOrder.length - 1 && onAirId === seg.id;
        return `
          <div class="pipeline-card${isOnAir ? ' on-air' : ''}">
            ${isOnAir ? '<div class="on-air-badge">On Air</div>' : ''}
            <div class="type">${seg.type}</div>
            <div class="seed">${(seg.seed || 'filler').slice(0, 30)}${(seg.seed || '').length > 30 ? '...' : ''}</div>
            <div class="duration">${seg.estimatedDuration || 0}s</div>
          </div>
        `;
      }).join('');
    }

    function renderArchive(segments) {
      const aired = segments.filter(s => s.status === 'aired');
      const container = document.getElementById('archive-section');

      if (aired.length === 0) {
        container.innerHTML = '<span class="empty-state">No archived segments</span>';
        return;
      }

      // Show most recent first
      container.innerHTML = aired.slice().reverse().map(seg => `
        <div class="archive-item">
          <strong>${seg.type}</strong>: ${(seg.seed || 'filler').slice(0, 50)}
        </div>
      `).join('');
    }

    function renderChatInbox(inbox) {
      const container = document.getElementById('chat-inbox');

      if (!inbox || inbox.length === 0) {
        container.innerHTML = '<span class="empty-state">No messages</span>';
        return;
      }

      container.innerHTML = inbox.map(card => {
        const responsePreview = card.response
          ? `<div class="response-preview">${card.response.speaker}: ${card.response.text.slice(0, 50)}...</div>`
          : '';
        return `
          <div class="chat-card" data-id="${card.id}">
            <div class="username">${card.username}</div>
            <div class="text">${card.text}</div>
            ${responsePreview}
            <div class="actions">
              <button class="btn-small btn-primary queue-btn">Queue</button>
              <button class="btn-small btn-danger dismiss-btn">Dismiss</button>
            </div>
          </div>
        `;
      }).join('');

      // Attach handlers
      container.querySelectorAll('.chat-card').forEach(el => {
        const cardId = el.dataset.id;
        const card = inbox.find(c => c.id === cardId);

        el.querySelector('.queue-btn').addEventListener('click', async (e) => {
          e.target.disabled = true;
          e.target.textContent = 'Queuing...';
          try {
            if (card.response) {
              await apiPost('/api/orchestrator/queue-response', {
                speaker: card.response.speaker,
                text: card.response.text,
                seed: card.text
              });
            } else {
              const result = await apiPost('/api/orchestrator/expand-chat', { message: card.text });
              if (!result.error) {
                await apiPost(`/api/orchestrator/render/${result.id}`, {});
              }
            }
            await fetch(`${API_BASE}/api/orchestrator/chat/inbox/${cardId}`, { method: 'DELETE' });
            refreshAll();
          } catch (err) {
            alert(err.message);
          }
        });

        el.querySelector('.dismiss-btn').addEventListener('click', async () => {
          await fetch(`${API_BASE}/api/orchestrator/chat/inbox/${cardId}`, { method: 'DELETE' });
          refreshAll();
        });
      });
    }

    function updateStatus(status, bufferHealth) {
      const statusEl = document.getElementById('playback-status');
      const bufferEl = document.getElementById('buffer-info');
      const dot = document.getElementById('status-dot');

      dot.className = 'status-dot';

      if (status.isPaused) {
        statusEl.textContent = 'Paused';
        dot.classList.add('paused');
      } else if (status.isPlaying) {
        if (status.currentSegmentId) {
          statusEl.textContent = 'Playing';
          dot.classList.add('playing');
        } else {
          statusEl.textContent = 'Waiting...';
        }
      } else {
        statusEl.textContent = 'Stopped';
        dot.classList.add('stopped');
      }

      currentSegmentId = status.currentSegmentId;
      bufferEl.textContent = `Buffer: ${bufferHealth?.totalSeconds || 0}s (${bufferHealth?.readyCount || 0})`;
    }

    async function refreshAll() {
      try {
        const [pipeline, status, inbox, chatConfig] = await Promise.all([
          apiGet('/api/pipeline'),
          apiGet('/api/orchestrator/status'),
          apiGet('/api/orchestrator/chat/inbox'),
          apiGet('/api/orchestrator/chat/config')
        ]);

        renderRendering(pipeline.segments || []);
        renderPipeline(pipeline.segments || [], status.currentSegmentId);
        renderArchive(pipeline.segments || []);
        renderChatInbox(inbox.inbox || []);
        updateStatus(status, pipeline.bufferHealth);

        document.getElementById('filler-toggle').checked = status.fillerEnabled || false;
        document.getElementById('auto-approve-toggle').checked = chatConfig.autoApprove || false;
      } catch (err) {
        console.error('Refresh failed:', err);
      }
    }

    function connectWebSocket() {
      ws = new WebSocket(`ws://${window.location.host}/ws/orchestrator`);

      ws.onopen = () => {
        document.getElementById('playback-status').textContent = 'Connected';
        refreshAll();
      };

      ws.onmessage = (event) => {
        const payload = JSON.parse(event.data);
        if (payload.event === 'pipeline:update') {
          const data = payload.data;
          renderRendering(data.segments || []);
          renderPipeline(data.segments || [], data.currentSegmentId);
          renderArchive(data.segments || []);
          updateStatus(data.playbackStatus || {}, data.bufferHealth);
        }
        if (payload.event === 'chat:new-card') {
          refreshAll();
        }
      };

      ws.onclose = () => {
        document.getElementById('playback-status').textContent = 'Reconnecting...';
        setTimeout(connectWebSocket, 2000);
      };
    }

    // Event handlers
    document.getElementById('play-btn').addEventListener('click', async () => {
      await apiPost('/api/orchestrator/play', {});
      refreshAll();
    });

    document.getElementById('pause-btn').addEventListener('click', async () => {
      await apiPost('/api/orchestrator/pause', {});
      refreshAll();
    });

    document.getElementById('filler-toggle').addEventListener('change', async (e) => {
      await apiPost('/api/orchestrator/filler', { enabled: e.target.checked });
    });

    document.getElementById('auto-approve-toggle').addEventListener('change', async (e) => {
      await apiPost('/api/orchestrator/chat/auto-approve', { enabled: e.target.checked });
    });

    document.getElementById('create-btn').addEventListener('click', async () => {
      const seed = document.getElementById('seed-input').value.trim();
      if (!seed) return;

      const btn = document.getElementById('create-btn');
      btn.disabled = true;
      btn.textContent = 'Creating...';

      try {
        const result = await apiPost('/api/orchestrator/expand', { seed, mediaRefs: [] });
        if (result.error) {
          alert(result.error);
        } else {
          await apiPost(`/api/orchestrator/render/${result.id}`, {});
          document.getElementById('seed-input').value = '';
        }
      } catch (err) {
        alert(err.message);
      }

      btn.disabled = false;
      btn.textContent = 'Create';
      refreshAll();
    });

    document.getElementById('clear-archive').addEventListener('click', async () => {
      await fetch(`${API_BASE}/api/pipeline/clear-aired`, { method: 'DELETE' });
      refreshAll();
    });

    // Initialize
    connectWebSocket();
  </script>
</body>
</html>
